---
phase: 02-live-pricing-core-calculations
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/sync.ts
  - src/app/api/sync/route.ts
  - src/app/api/sync/status/route.ts
  - src/hooks/use-sync.ts
  - src/hooks/use-last-synced.ts
  - src/components/layout/app-sidebar.tsx
autonomous: true

must_haves:
  truths:
    - "POST /api/sync fetches prices from FMP, updates symbols in NocoDB, and inserts price_history records"
    - "Sync streams progress to the client as NDJSON (type: start, progress, complete, error)"
    - "Sidebar shows 'Last synced' as relative time that updates without page refresh"
    - "Sidebar 'Sync Now' button triggers sync and shows progress while syncing"
    - "GET /api/sync/status returns the last_synced timestamp from NocoDB settings"
    - "Price history records are inserted for each successfully synced symbol"
    - "USD/GBP exchange rate is fetched and stored during sync"
  artifacts:
    - path: "src/lib/sync.ts"
      provides: "Sync orchestration logic"
      exports: ["runSync"]
    - path: "src/app/api/sync/route.ts"
      provides: "POST handler for /api/sync with streaming progress"
      exports: ["POST"]
    - path: "src/app/api/sync/status/route.ts"
      provides: "GET handler returning last-synced timestamp"
      exports: ["GET"]
    - path: "src/hooks/use-sync.ts"
      provides: "SWR mutation hook for triggering sync"
      exports: ["useSync"]
    - path: "src/hooks/use-last-synced.ts"
      provides: "SWR polling hook for last-synced timestamp"
      exports: ["useLastSynced"]
    - path: "src/components/layout/app-sidebar.tsx"
      provides: "Sidebar footer with Sync Now button and last-synced display"
      contains: "useSync"
  key_links:
    - from: "src/lib/sync.ts"
      to: "src/lib/fmp.ts"
      via: "import fetchBatchQuotes, fetchForexRate"
      pattern: "import.*fetchBatchQuotes.*from.*fmp"
    - from: "src/lib/sync.ts"
      to: "src/lib/nocodb.ts"
      via: "import updateRecords, createRecords, getAllRecords"
      pattern: "import.*updateRecords.*from.*nocodb"
    - from: "src/app/api/sync/route.ts"
      to: "src/lib/sync.ts"
      via: "import runSync"
      pattern: "import.*runSync.*from.*sync"
    - from: "src/hooks/use-sync.ts"
      to: "/api/sync"
      via: "fetch POST with stream reading"
      pattern: 'fetch.*"/api/sync"'
    - from: "src/components/layout/app-sidebar.tsx"
      to: "src/hooks/use-sync.ts"
      via: "import useSync hook"
      pattern: "import.*useSync.*from.*use-sync"
    - from: "src/components/layout/app-sidebar.tsx"
      to: "src/hooks/use-last-synced.ts"
      via: "import useLastSynced hook"
      pattern: "import.*useLastSynced.*from.*use-last-synced"
---

<objective>
Wire up the full sync pipeline: FMP fetch -> NocoDB update -> price history insert, exposed via a streaming API route with real-time UI feedback in the sidebar.

Purpose: This is the central data freshness mechanism. Without it, the dashboard shows stale prices from migration. The sync pipeline connects FMP data to the local database and gives users control over when prices refresh.

Output: Sync orchestration module, two API route handlers (POST sync, GET status), two SWR hooks, and updated sidebar with sync button + last-synced indicator.
</objective>

<execution_context>
@/Users/skylight/.claude/sky/workflows/execute-plan.md
@/Users/skylight/.claude/sky/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-live-pricing-core-calculations/02-RESEARCH.md
@.planning/phases/02-live-pricing-core-calculations/02-01-SUMMARY.md

@src/lib/nocodb.ts
@src/lib/types.ts
@src/lib/fmp.ts
@src/lib/fmp-types.ts
@src/components/layout/app-sidebar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync orchestration and API route handlers</name>
  <files>src/lib/sync.ts, src/app/api/sync/route.ts, src/app/api/sync/status/route.ts</files>
  <action>
Create `src/lib/sync.ts` -- the sync orchestration module:

- `import "server-only"`
- Import `fetchBatchQuotes`, `fetchForexRate` from `./fmp`
- Import `getAllRecords`, `updateRecords`, `createRecords`, `updateRecord`, `listRecords` from `./nocodb`
- Import types: `SymbolRecord`, `PriceHistoryRecord`, `SettingRecord`

Define a `SyncProgress` type:
```typescript
type SyncProgress =
  | { type: "start"; total: number }
  | { type: "progress"; completed: number; total: number; batch: number }
  | { type: "complete"; timestamp: string; updated: number; failed: number }
  | { type: "error"; message: string }
```

Export `async function* runSync(): AsyncGenerator<SyncProgress>`:
1. Yield `{ type: "start", total }` with the symbol count
2. Fetch all symbols from NocoDB: `getAllRecords<SymbolRecord>("symbols")`
3. Build a map of symbol ticker -> NocoDB row Id
4. Extract all tickers, split into batches of 30
5. For each batch:
   a. Call `fetchBatchQuotes(batch)`
   b. Map FMP quote fields to NocoDB SymbolRecord fields:
      - current_price = quote.price
      - previous_close = quote.previousClose
      - change_pct = quote.changesPercentage
      - day_high = quote.dayHigh, day_low = quote.dayLow
      - year_high = quote.yearHigh, year_low = quote.yearLow
      - market_cap = quote.marketCap
      - pe_ratio = quote.pe, eps = quote.eps
      - avg_volume = quote.avgVolume
      - price_avg_50 = quote.priceAvg50, price_avg_200 = quote.priceAvg200
      - last_price_update = new Date().toISOString()
   c. Call `updateRecords("symbols", updates)` (bulk update)
   d. Prepare price_history records: `{ symbol, date: today (YYYY-MM-DD), close_price: quote.price, volume: quote.volume }` for each quote
   e. Call `createRecords("price_history", historyRecords)` (bulk insert)
   f. Yield `{ type: "progress", completed, total, batch: batchIndex }` after each batch
   g. Wrap each batch in try/catch -- on failure, log error, track failed count, continue with next batch (partial failure handling)
6. Fetch forex rate: `fetchForexRate("USDGBP")` -- wrap in try/catch, log if fails
7. If forex rate fetched, store in settings table: update or create a setting with key "usd_gbp_rate" and value = rate.bid (or rate.ask -- use bid as convention). Also store "usd_gbp_rate_updated" with current timestamp.
8. Update the "last_synced" setting in NocoDB settings table with current ISO timestamp (create if not exists -- use `listRecords` to check, then `updateRecord` or `createRecord`)
9. Yield `{ type: "complete", timestamp, updated, failed }`

Handle the "create if not exists" for settings by: query `listRecords("settings", { where: "(key,eq,last_synced)" })`. If exists, update. If not, create.

Create `src/app/api/sync/route.ts` -- POST handler:
- Import `runSync` from `@/lib/sync`
- Create a `ReadableStream` that iterates the async generator
- Encode each `SyncProgress` object as a JSON line (NDJSON: `JSON.stringify(progress) + "\n"`)
- Return `new Response(stream, { headers: { "Content-Type": "application/x-ndjson", "Cache-Control": "no-cache" } })`

Create `src/app/api/sync/status/route.ts` -- GET handler:
- Import `listRecords` from `@/lib/nocodb`
- Query settings table for "last_synced" key: `listRecords("settings", { where: "(key,eq,last_synced)" })`
- Return JSON: `{ lastSynced: setting?.value ?? null }`
- Set `cache: "no-store"` or use `export const dynamic = "force-dynamic"` to prevent caching

IMPORTANT: The sync module must handle the case where NocoDB settings table has no "last_synced" row yet (first sync ever).
IMPORTANT: Use `new Date().toISOString().split("T")[0]` for the YYYY-MM-DD date in price_history records.
  </action>
  <verify>
Run `pnpm typecheck` -- no errors.
Verify `runSync` is an async generator yielding `SyncProgress` types.
Verify POST /api/sync returns a ReadableStream with NDJSON content type.
Verify GET /api/sync/status returns JSON with lastSynced field.
  </verify>
  <done>
Sync pipeline fetches prices from FMP in batches, updates NocoDB symbols, inserts price_history records, stores forex rate and last_synced timestamp. Partial failures don't abort the entire sync. Route handlers expose the pipeline via HTTP with streaming progress.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SWR hooks and add sync UI to sidebar</name>
  <files>src/hooks/use-sync.ts, src/hooks/use-last-synced.ts, src/components/layout/app-sidebar.tsx</files>
  <action>
Create `src/hooks/use-sync.ts`:
- `"use client"` directive at top
- Import `useSWRMutation` from `"swr/mutation"`
- Define `SyncResult` type matching the "complete" progress shape
- Define `SyncState` type: `{ progress: { completed: number; total: number } | null; result: SyncResult | null }`
- The `triggerSync` fetcher function:
  1. POST to `/api/sync`
  2. Read the response body as a ReadableStream
  3. Parse each NDJSON line
  4. Track latest progress and result
  5. Return the final "complete" or "error" message
- Export `useSync()` hook returning `{ trigger, isSyncing: isMutating, progress, result, error }`
- Use `useState` to track intermediate progress (updated as stream chunks arrive)
- After successful sync, call `mutate("/api/sync/status")` to revalidate the last-synced SWR cache (import `useSWRConfig` or use the global `mutate`)

Create `src/hooks/use-last-synced.ts`:
- `"use client"` directive
- Import `useSWR` from `"swr"`
- Fetcher: `fetch("/api/sync/status").then(r => r.json())`
- Poll every 60 seconds: `{ refreshInterval: 60_000 }`
- Export `useLastSynced()` returning `{ lastSynced: string | null, isLoading, revalidate: mutate }`

Update `src/components/layout/app-sidebar.tsx`:
- Import `useSync` and `useLastSynced` hooks
- Import `RefreshCw` icon from lucide-react (for sync button)
- In the `SidebarFooter`, add a sync section with:
  1. **Last synced display**: Show relative time like "5 min ago" using `Intl.RelativeTimeFormat` or a simple helper function. If never synced, show "Never synced". If loading, show skeleton/placeholder.
  2. **Sync Now button**: A `Button` (shadcn) with `RefreshCw` icon that:
     - Calls `trigger()` from useSync on click
     - While `isSyncing`: shows spinning RefreshCw icon (add `animate-spin` class) + progress text ("Syncing 45/120...")
     - Disabled while syncing
     - After complete: last-synced auto-updates via SWR revalidation
  3. Use a compact layout that works in both expanded and collapsed sidebar states. When sidebar is collapsed (icon mode), show just the sync icon button without text.

For relative time formatting, create a small inline helper function (NOT a separate file):
```typescript
function formatRelativeTime(isoDate: string): string {
  const seconds = Math.floor((Date.now() - new Date(isoDate).getTime()) / 1000)
  if (seconds < 60) return "just now"
  const minutes = Math.floor(seconds / 60)
  if (minutes < 60) return `${minutes}m ago`
  const hours = Math.floor(minutes / 60)
  if (hours < 24) return `${hours}h ago`
  const days = Math.floor(hours / 24)
  return `${days}d ago`
}
```

The sidebar is already a Client Component ("use client"), so hooks work directly.

IMPORTANT: The Sync Now button must be a proper shadcn Button variant (outline or ghost, size "sm"). Keep the footer compact -- this is utility UI, not a primary action area.
  </action>
  <verify>
Run `pnpm typecheck` -- no errors.
Run `pnpm lint` -- no errors.
Verify the sidebar renders a sync button in the footer.
Verify `useSync` reads the NDJSON stream and tracks progress.
Verify `useLastSynced` polls /api/sync/status every 60 seconds.
  </verify>
  <done>
Sidebar footer shows "Last synced: X ago" that auto-updates via SWR polling. Sync Now button triggers the /api/sync endpoint, streams progress ("Syncing 45/120..."), and auto-refreshes the last-synced indicator when complete. The entire flow works without page reload.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes with zero errors
2. `pnpm lint` passes
3. `src/lib/sync.ts` imports from `fmp.ts` and `nocodb.ts` (not calling FMP directly)
4. `src/app/api/sync/route.ts` exports a POST function returning a streaming Response
5. `src/app/api/sync/status/route.ts` exports a GET function returning JSON
6. Sidebar footer contains sync button and last-synced display
7. No FMP API key references outside `src/lib/fmp.ts`
8. SWR hooks use proper client-side directives ("use client")
</verification>

<success_criteria>
- POST /api/sync streams NDJSON progress events and updates all symbol prices + price_history
- GET /api/sync/status returns the last-synced timestamp from NocoDB settings
- Sidebar displays relative time for last sync and a functional Sync Now button with progress
- Forex rate is fetched and stored in settings table during each sync
- Partial sync failures (individual batches) don't abort the entire sync
</success_criteria>

<output>
After completion, create `.planning/phases/02-live-pricing-core-calculations/02-02-SUMMARY.md`
</output>
