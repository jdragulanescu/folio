---
phase: 02-live-pricing-core-calculations
plan: 03
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/calculations.ts
  - src/lib/__tests__/calculations.test.ts
autonomous: true

must_haves:
  truths:
    - "Holdings calculation produces correct shares, avg cost, and realised P&L for a sequence of buys"
    - "Holdings calculation handles sells by reducing pool proportionally (Section 104)"
    - "Holdings calculation resets pool to zero when position is fully sold"
    - "Holdings calculation handles re-entry after full disposal (fresh pool)"
    - "Unrealised P&L is computed as (current price - avg cost) * shares"
    - "Weight allocation is computed as market value / total portfolio value"
    - "All arithmetic uses Big.js with no floating-point operations"
    - "Display values use .toFixed(2) at boundaries only"
  artifacts:
    - path: "src/lib/calculations.ts"
      provides: "Holdings engine with Section 104 pool, P&L, weight, portfolio aggregation"
      exports: ["computeHolding", "computePortfolio", "toDisplay"]
    - path: "src/lib/__tests__/calculations.test.ts"
      provides: "Test suite covering Section 104 pool edge cases"
      contains: "describe.*computeHolding"
  key_links:
    - from: "src/lib/calculations.ts"
      to: "big.js"
      via: "import Big from big.js"
      pattern: 'import Big from "big.js"'
    - from: "src/lib/__tests__/calculations.test.ts"
      to: "src/lib/calculations.ts"
      via: "import computeHolding, computePortfolio"
      pattern: "import.*computeHolding.*from.*calculations"
---

<objective>
Build the core financial calculations engine using TDD, implementing Section 104 pool cost basis, realised/unrealised P&L, and portfolio-level aggregations with Big.js decimal arithmetic.

Purpose: This is the mathematical heart of the dashboard. Every number shown to the user (cost basis, P&L, weight, total portfolio value) flows through this library. Getting it wrong means the dashboard shows incorrect financial data. TDD ensures correctness by testing edge cases before implementation.

Output: A pure-function calculations library (`calculations.ts`) and comprehensive test suite (`calculations.test.ts`) covering all Section 104 pool edge cases.
</objective>

<execution_context>
@/Users/skylight/.claude/sky/workflows/execute-plan.md
@/Users/skylight/.claude/sky/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-live-pricing-core-calculations/02-RESEARCH.md

@src/lib/types.ts
</context>

<feature>
  <name>Section 104 Holdings Calculator</name>
  <files>src/lib/calculations.ts, src/lib/__tests__/calculations.test.ts</files>
  <behavior>
The calculations engine processes sorted transactions and current prices to produce holdings with accurate P&L.

**Setup:** Before writing tests, install vitest as the test runner:
```bash
pnpm add -D vitest
```
Add to package.json scripts: `"test": "vitest run", "test:watch": "vitest"`

**Core function: `computeHolding`**

Input: Array of transactions (sorted by date asc) + current price
Output: `{ shares, avgCost, totalCost, realisedPnl, unrealisedPnl, marketValue }`

Test cases (RED phase -- write all tests first):

1. **Single buy**: Buy 100 shares @ $10 ($1000), current price $12
   - shares = 100, avgCost = 10.00, totalCost = 1000.00
   - marketValue = 1200.00, unrealisedPnl = 200.00, realisedPnl = 0.00

2. **Multiple buys (cost averaging)**: Buy 100 @ $10, Buy 50 @ $14
   - shares = 150, totalCost = 1700.00, avgCost = 11.33 (1700/150 = 11.333...)
   - With current price $12: marketValue = 1800.00, unrealisedPnl = 100.00

3. **Buy then partial sell**: Buy 100 @ $10, Sell 40 @ $15
   - After sell: shares = 60, avgCost = 10.00, totalCost = 600.00
   - realisedPnl = 40 * (15 - 10) = 200.00
   - With current price $12: unrealisedPnl = 60 * (12 - 10) = 120.00

4. **Full disposal (pool reset)**: Buy 100 @ $10, Sell 100 @ $15
   - shares = 0, avgCost = 0, totalCost = 0
   - realisedPnl = 100 * (15 - 10) = 500.00
   - marketValue = 0, unrealisedPnl = 0

5. **Re-entry after full disposal**: Buy 100 @ $10, Sell 100 @ $15, Buy 50 @ $20
   - shares = 50, avgCost = 20.00 (fresh pool after reset), totalCost = 1000.00
   - realisedPnl = 500.00 (carried from the disposal)
   - With current price $22: unrealisedPnl = 50 * (22 - 20) = 100.00

6. **Multiple buys and sells (complex)**: Buy 200 @ $50, Buy 100 @ $60, Sell 150 @ $70
   - Pool after buys: 300 shares, totalCost = $16000, avgCost = $53.333...
   - Sell 150: costOfSold = 150 * 53.333... = $8000, realisedPnl = 150*70 - 8000 = 2500.00
   - Remaining: 150 shares, totalCost = 8000.00, avgCost = 53.33
   - With current price $75: unrealisedPnl = 150 * (75 - 53.333...) = 3250.00

7. **Fractional shares**: Buy 10.5 shares @ $100.50
   - shares = 10.5, avgCost = 100.50, totalCost = 1055.25

8. **Sell with zero shares (edge case)**: Sell 50 @ $10 with no prior buys
   - Should skip the sell (pool is empty), shares = 0, all P&L = 0

9. **Transaction sort order**: Provide transactions in wrong date order -- function should sort by date asc, process buys before sells on same day
   - Buy 100 @ $10 (date: 2024-01-15), Sell 50 @ $12 (date: 2024-01-10, but this is BEFORE the buy)
   - Correctly sorted: sell first (skipped, no shares), then buy
   - Result: shares = 100, avgCost = 10.00

**Portfolio-level function: `computePortfolio`**

Input: Map of symbol -> { transactions, currentPrice, name, sector, strategy }
Output: Array of Holding objects + portfolio totals

Test cases:
10. **Two-symbol portfolio weights**: Symbol A (market value $6000), Symbol B (market value $4000)
    - A weight = 60%, B weight = 40%

11. **Portfolio totals**: Sum of all market values, sum of all unrealised P&L, sum of all realised P&L

**Utility: `toDisplay(value: Big, dp?: number): number`**
Converts Big.js value to number with specified decimal places (default 2).

12. **toDisplay precision**: Big("10.33333").toFixed(2) = 10.33 (not 10.333)

**IMPORTANT Big.js rules:**
- Import Big from "big.js"
- Set `Big.RM = Big.roundHalfUp` at module level (RM = 1, financial rounding)
- Leave Big.DP at default 20 (never set to 2 globally)
- All intermediate values are Big instances
- Only convert to number at the toDisplay boundary
- The `amount` field in TransactionRecord = price * shares (pre-computed, use it directly rather than recomputing)
  </behavior>
  <implementation>
**GREEN phase -- implement to pass all tests:**

`src/lib/calculations.ts`:

1. Define input types:
   ```typescript
   interface TransactionInput {
     type: "Buy" | "Sell"
     shares: number
     price: number
     amount: number
     date: string
   }
   ```

2. `computeHolding(transactions: TransactionInput[], currentPrice: number)`:
   - Sort transactions by date ascending. For same date, buys before sells.
   - Iterate using Section 104 pool algorithm (see research doc for exact logic)
   - Return object with both Big values (for composition) and display values

3. `computePortfolio(holdings: Map<string, { transactions: TransactionInput[]; currentPrice: number; name: string; sector: string | null; strategy: string | null }>)`:
   - Call `computeHolding` for each symbol
   - Compute total portfolio market value
   - Compute weight = symbol market value / total market value
   - Return array of Holding objects with all display-ready values

4. `toDisplay(value: Big, dp: number = 2): number`:
   - Return `Number(value.toFixed(dp))`

**REFACTOR phase:**
- Extract common types if needed
- Ensure no redundant calculations
- Verify all edge cases still pass
  </implementation>
</feature>

<verification>
1. `pnpm test` -- all tests pass
2. `pnpm typecheck` -- no errors
3. `pnpm lint` -- no errors
4. No `number * number` arithmetic in calculations.ts (all arithmetic via Big.js)
5. Big.RM set to roundHalfUp
6. Big.DP NOT set to 2 (verify default 20 is used)
7. Test coverage includes: single buy, multiple buys, partial sell, full disposal, re-entry, fractional shares, zero-shares sell, wrong sort order
</verification>

<success_criteria>
- All 12+ test cases pass with `pnpm test`
- Section 104 pool correctly handles buy/sell/reset/re-entry sequences
- No floating-point arithmetic -- every calculation uses Big.js
- Display values are precise to 2 decimal places at output boundary
- Portfolio weights sum to 100% (within rounding tolerance)
</success_criteria>

<output>
After completion, create `.planning/phases/02-live-pricing-core-calculations/02-03-SUMMARY.md`
</output>
