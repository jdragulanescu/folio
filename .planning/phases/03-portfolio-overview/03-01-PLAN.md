---
phase: 03-portfolio-overview
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/portfolio.ts
  - src/lib/format.ts
  - src/app/page.tsx
  - package.json
  - src/components/ui/table.tsx
  - src/components/ui/card.tsx
  - src/components/ui/chart.tsx
  - src/components/ui/badge.tsx
  - src/components/ui/dropdown-menu.tsx
autonomous: true

must_haves:
  truths:
    - "getPortfolioData() fetches all data from NocoDB in parallel and returns serialisable plain-number objects"
    - "Only holdings with shares > 0 are included in the returned data"
    - "The page at / renders without serialisation errors (no Big.js values cross the server-client boundary)"
    - "All required shadcn components and npm dependencies are installed"
  artifacts:
    - path: "src/lib/portfolio.ts"
      provides: "Server-side data assembly with DisplayHolding and PortfolioData types"
      exports: ["getPortfolioData", "DisplayHolding", "PortfolioData"]
    - path: "src/lib/format.ts"
      provides: "Centralised financial number formatting utilities"
      exports: ["formatCurrency", "formatPercent", "formatNumber", "formatCompact", "pnlClassName"]
    - path: "src/app/page.tsx"
      provides: "Server Component page shell calling getPortfolioData and passing to client components"
  key_links:
    - from: "src/lib/portfolio.ts"
      to: "src/lib/calculations.ts"
      via: "import computePortfolio, toDisplay"
      pattern: "import.*computePortfolio.*calculations"
    - from: "src/lib/portfolio.ts"
      to: "src/lib/nocodb.ts"
      via: "import getAllRecords, fetchParallel"
      pattern: "import.*getAllRecords.*nocodb"
    - from: "src/app/page.tsx"
      to: "src/lib/portfolio.ts"
      via: "import getPortfolioData"
      pattern: "import.*getPortfolioData.*portfolio"
---

<objective>
Install all Phase 3 dependencies, create the server-side data assembly layer, and build the portfolio page shell that fetches, computes, and serialises portfolio data for client components.

Purpose: This is the foundation for the entire Phase 3 dashboard. Every client component (table, cards, charts, movers) depends on the data shape produced here. The serialisation boundary (Big.js to plain numbers) is the critical engineering challenge.

Output: `src/lib/portfolio.ts` (data assembly + types), `src/lib/format.ts` (formatting utilities), `src/app/page.tsx` (page shell with layout), plus all shadcn/npm dependencies installed.
</objective>

<execution_context>
@/Users/skylight/.claude/sky/workflows/execute-plan.md
@/Users/skylight/.claude/sky/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/calculations.ts
@src/lib/types.ts
@src/lib/nocodb.ts
@src/lib/fmp.ts
@src/app/layout.tsx
@src/styles/globals.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and shadcn components</name>
  <files>package.json, src/components/ui/table.tsx, src/components/ui/card.tsx, src/components/ui/chart.tsx, src/components/ui/badge.tsx, src/components/ui/dropdown-menu.tsx</files>
  <action>
Install npm packages and shadcn UI components needed for the entire Phase 3.

1. Install npm packages:
```bash
pnpm add @tanstack/react-table recharts
```

Note: `recharts` may already be in package.json from the project stack -- check first, only install if missing. `@tanstack/react-table` is definitely not installed.

2. Install shadcn components (one command):
```bash
pnpm dlx shadcn@latest add table card chart badge dropdown-menu
```

This installs all five components into `src/components/ui/`. The `chart` component also brings in `recharts` as a peer dependency if not already present.

3. Verify all files exist:
- `src/components/ui/table.tsx`
- `src/components/ui/card.tsx`
- `src/components/ui/chart.tsx`
- `src/components/ui/badge.tsx`
- `src/components/ui/dropdown-menu.tsx`

4. Verify the build still passes: `pnpm typecheck`
  </action>
  <verify>
`ls src/components/ui/table.tsx src/components/ui/card.tsx src/components/ui/chart.tsx src/components/ui/badge.tsx src/components/ui/dropdown-menu.tsx` all exist. `pnpm typecheck` passes.
  </verify>
  <done>All five shadcn components installed. @tanstack/react-table and recharts in package.json. Build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Create formatting utilities and server-side data assembly</name>
  <files>src/lib/format.ts, src/lib/portfolio.ts</files>
  <action>
Create two new files: a formatting utilities module and the server-side portfolio data assembly function.

**File 1: `src/lib/format.ts`**

Create centralised financial formatting utilities used across all Phase 3 components. This file is NOT server-only (used by client components too).

```typescript
// Centralised financial display formatting utilities.
// Used by both Server and Client Components.

/**
 * Format a number as GBP currency (e.g., "£12,345.67").
 */
export function formatCurrency(value: number): string {
  return new Intl.NumberFormat("en-GB", {
    style: "currency",
    currency: "GBP",
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(value)
}

/**
 * Format a number as a signed percentage (e.g., "+15.23%", "-3.45%").
 */
export function formatPercent(value: number): string {
  const sign = value > 0 ? "+" : ""
  return `${sign}${value.toFixed(2)}%`
}

/**
 * Format a number with locale-aware thousands separators.
 */
export function formatNumber(value: number, dp: number = 2): string {
  return new Intl.NumberFormat("en-GB", {
    minimumFractionDigits: dp,
    maximumFractionDigits: dp,
  }).format(value)
}

/**
 * Format a large number in compact notation (e.g., "£1.2B", "£456M").
 * Useful for market cap display.
 */
export function formatCompact(value: number): string {
  return new Intl.NumberFormat("en-GB", {
    style: "currency",
    currency: "GBP",
    notation: "compact",
    maximumFractionDigits: 1,
  }).format(value)
}

/**
 * Return Tailwind class for gain/loss colouring.
 * Uses CSS custom properties --color-gain and --color-loss from globals.css.
 */
export function pnlClassName(value: number): string {
  if (value > 0) return "text-gain"
  if (value < 0) return "text-loss"
  return "text-muted-foreground"
}
```

**File 2: `src/lib/portfolio.ts`**

Create the server-side data assembly function. This is the critical serialisation boundary.

Key requirements:
- Import `server-only` at the top (prevents client-side import)
- Fetch symbols, transactions, deposits, and options in parallel using `fetchParallel`
- Group transactions by symbol, build `SymbolInput` map for `computePortfolio`
- Call `computePortfolio()` and get `PortfolioResult` with Big.js values
- Filter to only holdings with `shares.gt(0)` (PORT-03: exclude fully sold)
- Convert ALL Big.js values to plain numbers via `toDisplay()` -- this is the serialisation boundary
- Compute `unrealisedPnlPct` as `(unrealisedPnl / totalCost) * 100`
- Compute portfolio-level `dayChange` as `sum(holding.marketValue * changePct / 100)` and `dayChangePct` as dayChange / totalMarketValue * 100
- Compute `totalDeposited` from deposits sum
- Compute `optionsPremium` from options where `buy_sell === "Sell"` (premium received from selling)
- Determine primary `platform` per holding: the broker with the most shares for that symbol
- Include `changePct` from the symbol record's `change_pct` field (populated by FMP sync)

Export these TypeScript interfaces (all numbers, no Big.js):

```typescript
export interface DisplayHolding {
  symbol: string
  name: string
  sector: string | null
  strategy: string | null
  platform: string | null
  currentPrice: number
  previousClose: number | null
  changePct: number | null
  shares: number
  avgCost: number
  totalCost: number
  marketValue: number
  unrealisedPnl: number
  unrealisedPnlPct: number
  realisedPnl: number
  weight: number
}

export interface PortfolioData {
  holdings: DisplayHolding[]
  totals: {
    totalMarketValue: number
    totalCost: number
    totalUnrealisedPnl: number
    totalRealisedPnl: number
  }
  totalDeposited: number
  optionsPremium: number
  dayChange: number
  dayChangePct: number
}
```

Export `async function getPortfolioData(): Promise<PortfolioData>`.

For the platform (broker) per holding: iterate transactions for each symbol and tally shares per platform, then pick the platform with the highest tally. Handle the case where some transactions have null platform gracefully (skip them in the tally, fall back to null if all are null).

For dayChange calculation at the portfolio level: for each holding, compute `holdingDayChange = marketValue * (changePct / 100)` where changePct comes from the symbol record. Sum all holdingDayChange values to get portfolio dayChange. Then `dayChangePct = dayChange / totalMarketValue * 100`. If `changePct` is null for a symbol, treat that symbol's day change as 0.

Important: `computePortfolio` expects a `Map<string, SymbolInput>`. `SymbolInput` requires: `transactions: TransactionInput[]`, `currentPrice: number`, `name: string`, `sector: string | null`, `strategy: string | null`. Only include symbols that have BOTH transactions AND a non-null current_price.
  </action>
  <verify>
`pnpm typecheck` passes. Both files exist and export the documented interfaces and functions. `portfolio.ts` imports `server-only`. No Big.js types in the exported interfaces.
  </verify>
  <done>`getPortfolioData()` returns fully serialisable `PortfolioData` with all Big.js values converted to numbers. Formatting utilities exported from `format.ts`. Only active holdings (shares > 0) included.</done>
</task>

<task type="auto">
  <name>Task 3: Build portfolio page shell with layout structure</name>
  <files>src/app/page.tsx</files>
  <action>
Replace the existing placeholder `src/app/page.tsx` with the real Server Component that calls `getPortfolioData()` and renders the dashboard layout structure.

The page must:
1. Be an async Server Component (no "use client" directive)
2. Import and call `getPortfolioData()` from `@/lib/portfolio`
3. Define the page layout grid structure for all Phase 3 components
4. Pass data as props to client component placeholders (which will be built in plans 03-02 and 03-03)

For now, use simple placeholder `<div>` sections where the actual client components will go. Each placeholder should clearly indicate what will replace it:
- Summary cards section (top of page)
- Holdings table section (main area, left/center)
- Allocation charts section (sidebar right)
- Top movers section (below charts)

Layout structure:
```
[ Summary Cards (full width) ]
[ Holdings Table (2/3 width)  | Charts + Movers (1/3 width) ]
```

Use Tailwind grid: `grid grid-cols-1 lg:grid-cols-3 gap-6` for the main content area, with the holdings table spanning `lg:col-span-2`.

Add a page heading with title "Portfolio" and a brief description.

For the placeholder sections, render the actual data shape as JSON or simple text so we can verify the data pipeline works end-to-end:
- Show `data.totals.totalMarketValue` formatted as currency in the summary cards placeholder
- Show `data.holdings.length` count in the table placeholder
- This proves the full data pipeline (NocoDB fetch -> computePortfolio -> toDisplay -> render) works

Import the formatting utilities from `@/lib/format` and use `formatCurrency` to display values.

Do NOT add "use client" to this file. It must remain a Server Component.
  </action>
  <verify>
`pnpm typecheck` passes. `pnpm lint` passes. The page is an async function without "use client". It imports `getPortfolioData` and `formatCurrency`. The layout grid structure is in place.
  </verify>
  <done>Portfolio page Server Component calls `getPortfolioData()`, renders layout grid with placeholder sections showing live data. No serialisation errors. Full data pipeline verified end-to-end.</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes with zero errors
2. `pnpm lint` passes
3. `src/lib/portfolio.ts` exports `getPortfolioData`, `DisplayHolding`, `PortfolioData`
4. `src/lib/format.ts` exports `formatCurrency`, `formatPercent`, `formatNumber`, `formatCompact`, `pnlClassName`
5. `src/app/page.tsx` is an async Server Component importing from `@/lib/portfolio`
6. All five shadcn components exist in `src/components/ui/`
7. `@tanstack/react-table` and `recharts` are in `package.json`
</verification>

<success_criteria>
- All dependencies installed and building
- Server-side data assembly returns fully serialisable portfolio data (no Big.js values)
- Only holdings with shares > 0 included
- Page shell renders without errors with placeholder sections showing live data
- Format utilities centralised and available for all Phase 3 components
</success_criteria>

<output>
After completion, create `.planning/phases/03-portfolio-overview/03-01-SUMMARY.md`
</output>
